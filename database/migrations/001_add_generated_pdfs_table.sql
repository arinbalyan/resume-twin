-- ============================================================================
-- MIGRATION: Add Generated PDFs Table
-- Description: Stores metadata for PDFs generated by users, linked to Supabase Storage
-- Created: 2025-11-30
-- ============================================================================

-- ============================================================================
-- GENERATED PDFs TABLE
-- Stores metadata about PDFs that are stored in Supabase Storage
-- ============================================================================

CREATE TABLE IF NOT EXISTS generated_pdfs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- User ownership (REQUIRED for access control)
    user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
    
    -- Resume reference (optional - links to a resume version if applicable)
    resume_version_id UUID REFERENCES resume_versions(id) ON DELETE SET NULL,
    
    -- File information
    file_name TEXT NOT NULL,                          -- Original/display name: "John_Doe_Resume_2025.pdf"
    storage_path TEXT NOT NULL UNIQUE,                -- S3/Supabase path: "resumes/{user_id}/{uuid}.pdf"
    file_size BIGINT NOT NULL,                        -- Size in bytes
    mime_type TEXT DEFAULT 'application/pdf',         -- MIME type
    
    -- Template information
    template_name TEXT,                               -- Which template was used
    template_type TEXT DEFAULT 'html',                -- "html" or "latex"
    
    -- Generation metadata
    generation_method TEXT NOT NULL,                  -- "pdfshift", "html2pdf", "browserless", "weasyprint", "latex"
    generation_time_ms INTEGER,                       -- How long it took to generate
    generation_status TEXT DEFAULT 'completed',       -- "pending", "generating", "completed", "failed"
    error_message TEXT,                               -- Error details if generation failed
    
    -- Content hash for deduplication
    content_hash TEXT,                                -- SHA-256 hash of PDF content
    
    -- Access control
    is_public BOOLEAN DEFAULT FALSE,                  -- Allow public access via link?
    public_token UUID DEFAULT gen_random_uuid(),      -- Token for public sharing (if is_public=true)
    download_count INTEGER DEFAULT 0,                 -- Track downloads
    last_downloaded_at TIMESTAMP WITH TIME ZONE,     -- Last download timestamp
    
    -- Expiration (optional - for temporary PDFs)
    expires_at TIMESTAMP WITH TIME ZONE,              -- Auto-delete after this time
    
    -- Timestamps
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================================================
-- PDF DOWNLOAD LOGS TABLE
-- Audit log for PDF downloads
-- ============================================================================

CREATE TABLE IF NOT EXISTS pdf_download_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    pdf_id UUID NOT NULL REFERENCES generated_pdfs(id) ON DELETE CASCADE,
    
    -- Who downloaded
    user_id UUID REFERENCES profiles(id) ON DELETE SET NULL,  -- NULL if public download
    
    -- Download metadata
    ip_address INET,
    user_agent TEXT,
    download_type TEXT DEFAULT 'direct',              -- "direct", "presigned_url", "public_link"
    
    -- Timestamp
    downloaded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ============================================================================
-- INDEXES
-- ============================================================================

-- Fast lookup by user
CREATE INDEX idx_generated_pdfs_user_id ON generated_pdfs(user_id);

-- Fast lookup by resume version
CREATE INDEX idx_generated_pdfs_resume_version_id ON generated_pdfs(resume_version_id);

-- Find user's recent PDFs
CREATE INDEX idx_generated_pdfs_user_created ON generated_pdfs(user_id, created_at DESC);

-- Find by storage path (for S3 operations)
CREATE INDEX idx_generated_pdfs_storage_path ON generated_pdfs(storage_path);

-- Find by public token (for public sharing)
CREATE INDEX idx_generated_pdfs_public_token ON generated_pdfs(public_token) WHERE is_public = true;

-- Find expired PDFs for cleanup
CREATE INDEX idx_generated_pdfs_expires_at ON generated_pdfs(expires_at) WHERE expires_at IS NOT NULL;

-- Content hash for deduplication
CREATE INDEX idx_generated_pdfs_content_hash ON generated_pdfs(content_hash) WHERE content_hash IS NOT NULL;

-- Download logs indexes
CREATE INDEX idx_pdf_download_logs_pdf_id ON pdf_download_logs(pdf_id);
CREATE INDEX idx_pdf_download_logs_user_id ON pdf_download_logs(user_id);
CREATE INDEX idx_pdf_download_logs_downloaded_at ON pdf_download_logs(downloaded_at DESC);

-- ============================================================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================================================

ALTER TABLE generated_pdfs ENABLE ROW LEVEL SECURITY;
ALTER TABLE pdf_download_logs ENABLE ROW LEVEL SECURITY;

-- Users can only see their own PDFs
CREATE POLICY "Users can view own PDFs" 
    ON generated_pdfs FOR SELECT 
    USING (auth.uid() = user_id);

-- Users can insert their own PDFs
CREATE POLICY "Users can create own PDFs" 
    ON generated_pdfs FOR INSERT 
    WITH CHECK (auth.uid() = user_id);

-- Users can update their own PDFs
CREATE POLICY "Users can update own PDFs" 
    ON generated_pdfs FOR UPDATE 
    USING (auth.uid() = user_id);

-- Users can delete their own PDFs
CREATE POLICY "Users can delete own PDFs" 
    ON generated_pdfs FOR DELETE 
    USING (auth.uid() = user_id);

-- Public PDFs can be viewed by anyone (using public_token)
CREATE POLICY "Public PDFs are viewable" 
    ON generated_pdfs FOR SELECT 
    USING (is_public = true);

-- Download logs: Users can see logs for their own PDFs
CREATE POLICY "Users can view own PDF download logs" 
    ON pdf_download_logs FOR SELECT 
    USING (
        EXISTS (
            SELECT 1 FROM generated_pdfs 
            WHERE generated_pdfs.id = pdf_download_logs.pdf_id 
            AND generated_pdfs.user_id = auth.uid()
        )
    );

-- Download logs: System can insert logs
CREATE POLICY "System can insert download logs" 
    ON pdf_download_logs FOR INSERT 
    WITH CHECK (true);

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Update the updated_at timestamp
CREATE TRIGGER update_generated_pdfs_updated_at 
    BEFORE UPDATE ON generated_pdfs
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- FUNCTIONS
-- ============================================================================

-- Function to increment download count
CREATE OR REPLACE FUNCTION increment_pdf_download_count(pdf_uuid UUID)
RETURNS VOID AS $$
BEGIN
    UPDATE generated_pdfs 
    SET 
        download_count = download_count + 1,
        last_downloaded_at = NOW()
    WHERE id = pdf_uuid;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to clean up expired PDFs
CREATE OR REPLACE FUNCTION cleanup_expired_pdfs()
RETURNS INTEGER AS $$
DECLARE
    deleted_count INTEGER;
BEGIN
    WITH deleted AS (
        DELETE FROM generated_pdfs 
        WHERE expires_at IS NOT NULL 
        AND expires_at < NOW()
        RETURNING id
    )
    SELECT COUNT(*) INTO deleted_count FROM deleted;
    
    RETURN deleted_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- VIEWS
-- ============================================================================

-- User's PDF summary view
CREATE OR REPLACE VIEW user_pdf_summary AS
SELECT 
    user_id,
    COUNT(*) as total_pdfs,
    SUM(file_size) as total_storage_bytes,
    SUM(download_count) as total_downloads,
    MAX(created_at) as last_pdf_created,
    COUNT(*) FILTER (WHERE generation_status = 'completed') as successful_generations,
    COUNT(*) FILTER (WHERE generation_status = 'failed') as failed_generations
FROM generated_pdfs
GROUP BY user_id;

-- Recent downloads view
CREATE OR REPLACE VIEW recent_pdf_downloads AS
SELECT 
    dl.id,
    dl.pdf_id,
    gp.file_name,
    gp.user_id as pdf_owner_id,
    dl.user_id as downloader_id,
    dl.download_type,
    dl.downloaded_at
FROM pdf_download_logs dl
JOIN generated_pdfs gp ON gp.id = dl.pdf_id
ORDER BY dl.downloaded_at DESC
LIMIT 100;

-- ============================================================================
-- SUPABASE STORAGE BUCKET POLICY (Run in Supabase Dashboard)
-- ============================================================================

-- Note: Run this in the Supabase SQL Editor under Storage policies:
/*
-- Create the resumes bucket if it doesn't exist
INSERT INTO storage.buckets (id, name, public)
VALUES ('resumes', 'resumes', false)
ON CONFLICT (id) DO NOTHING;

-- Allow users to upload their own PDFs
CREATE POLICY "Users can upload own PDFs"
ON storage.objects FOR INSERT
WITH CHECK (
    bucket_id = 'resumes' 
    AND auth.uid()::text = (storage.foldername(name))[1]
);

-- Allow users to read their own PDFs
CREATE POLICY "Users can read own PDFs"
ON storage.objects FOR SELECT
USING (
    bucket_id = 'resumes' 
    AND auth.uid()::text = (storage.foldername(name))[1]
);

-- Allow users to delete their own PDFs
CREATE POLICY "Users can delete own PDFs"
ON storage.objects FOR DELETE
USING (
    bucket_id = 'resumes' 
    AND auth.uid()::text = (storage.foldername(name))[1]
);
*/
